#![windows_subsystem = "windows"]

mod app_model;
mod calculator;
mod db;
mod hooks;
mod scanner;
mod settings;
mod ui;
mod utils;

use app_model::{AppEntry, AppEntryType, AppManager};
use once_cell::sync::Lazy;
use std::fs::OpenOptions;
use std::io::Write;
use std::sync::Mutex;
use std::thread;
use windows::{
    core::*, Win32::Foundation::*, Win32::Graphics::Gdi::*, Win32::System::Com::*,
    Win32::System::LibraryLoader::*, Win32::System::Threading::*, Win32::UI::Controls::*,
    Win32::UI::Input::KeyboardAndMouse::*, Win32::UI::Shell::*, Win32::UI::WindowsAndMessaging::*,
};

// Global State
static mut MY_WINDOW: HWND = HWND(0);
static mut H_EDIT: HWND = HWND(0);
static mut H_LIST: HWND = HWND(0);
static mut KEYBOARD_HOOK: HHOOK = HHOOK(0);
static mut MOUSE_HOOK: HHOOK = HHOOK(0);
static APP_MANAGER: Lazy<Mutex<AppManager>> = Lazy::new(|| Mutex::new(AppManager::new()));

// Win key hold tracking
static mut WIN_KEY_PRESS_TIME: Option<std::time::Instant> = None;
static mut WIN_KEY_NATIVE_TRIGGERED: bool = false; // Flag to prevent double triggering
const WIN_KEY_HOLD_THRESHOLD_MS: u128 = 1000; // 1 second
const LLKHF_INJECTED: u32 = 0x10; // Flag indicating injected keyboard input
const LLMHF_INJECTED: u32 = 0x01; // Flag indicating injected mouse input
const WIN_KEY_TIMER_ID: usize = 9001;
const WIN_KEY_TIMER_INTERVAL: u32 = 100; // Check every 100ms
const WM_APP_TRAY: u32 = WM_USER + 1;
const ID_TRAY_EXIT: usize = 1001;
const ID_EDIT: i32 = 1002;
const ID_LIST: i32 = 1003;
const ID_CALC_RESULT: i32 = 1004;
static mut IS_DARK_MODE: bool = false;
static mut H_FONT: HFONT = HFONT(0);
static mut H_CALC_FONT: HFONT = HFONT(0);
static mut H_CALC_LABEL: HWND = HWND(0);

// UI constants for better readability
const PADDING: i32 = 15;
const SEARCH_HEIGHT: i32 = 35;
const CALC_LABEL_HEIGHT: i32 = 28;
const LIST_TOP: i32 = PADDING + SEARCH_HEIGHT + 5 + CALC_LABEL_HEIGHT + 5;
const ROW_HEIGHT: i32 = 36; // Height for list rows with larger icons

/// Write a message to the debug log file
fn write_debug_log(message: &str) {
    if let Ok(mut file) = OpenOptions::new()
        .create(true)
        .append(true)
        .open("oxistart_debug.log")
    {
        let timestamp = std::time::SystemTime::now()
            .duration_since(std::time::UNIX_EPOCH)
            .unwrap_or_default()
            .as_secs();
        let _ = writeln!(file, "[{}] {}", timestamp, message);
    }
}

/// Show a user-visible error message when app launch fails
unsafe fn show_launch_error(app_name: &str, error_code: u32) {
    use windows::Win32::UI::WindowsAndMessaging::*;

    let title = w!("Oxistart - Launch Failed");
    let message = format!(
        "Failed to launch '{}'\n\nError code: {}\n\nCheck oxistart_debug.log for details.",
        app_name, error_code
    );
    let message_wide = utils::to_wide_string(&message);

    MessageBoxW(
        None,
        PCWSTR(message_wide.as_ptr()),
        title,
        MB_OK | MB_ICONERROR,
    );
}

/// Resolve Microsoft AutoGenerated parse names
/// These are special Windows-generated names for Store apps and system apps
fn resolve_microsoft_auto_generated_path(auto_generated_path: &str) -> Option<String> {
    write_debug_log(&format!(
        "Attempting to resolve Microsoft AutoGenerated path: {}",
        auto_generated_path
    ));

    // Try to use IShellItem to resolve the parse name
    unsafe {
        match SHCreateItemFromParsingName::<PCWSTR, Option<&IBindCtx>, IShellItem>(
            PCWSTR(utils::to_wide_string(auto_generated_path).as_ptr()),
            None,
        ) {
            Ok(shell_item) => {
                // Try to get the display name with different flags
                if let Ok(display_name) = shell_item.GetDisplayName(SIGDN_FILESYSPATH) {
                    let path = display_name.to_string().unwrap_or_default();
                    if !path.is_empty() {
                        write_debug_log(&format!("Resolved to file system path: {}", path));
                        return Some(path);
                    }
                }

                // Try normal display name
                if let Ok(display_name) = shell_item.GetDisplayName(SIGDN_NORMALDISPLAY) {
                    let name = display_name.to_string().unwrap_or_default();
                    write_debug_log(&format!("Normal display name: {}", name));
                }

                // Try URL parsing name
                if let Ok(display_name) = shell_item.GetDisplayName(SIGDN_URL) {
                    let url = display_name.to_string().unwrap_or_default();
                    write_debug_log(&format!("URL parsing name: {}", url));
                }
            }
            Err(e) => {
                write_debug_log(&format!("SHCreateItemFromParsingName failed: {:?}", e));
            }
        }
    }

    // If IShellItem approach didn't work, try to find the app in common locations
    // Microsoft Store apps are typically in WindowsApps folder
    if let Some(guid_start) = auto_generated_path.find('{') {
        if let Some(guid_end) = auto_generated_path.find('}') {
            let guid = &auto_generated_path[guid_start..=guid_end];
            write_debug_log(&format!("Extracted GUID: {}", guid));

            // Try to find in WindowsApps directory
            let windows_apps_paths = [
                format!("C:\\Program Files\\WindowsApps\\{}", guid),
                format!("C:\\Program Files (x86)\\WindowsApps\\{}", guid),
            ];

            for path in windows_apps_paths {
                if std::path::Path::new(&path).exists() {
                    write_debug_log(&format!("Found WindowsApps path: {}", path));
                    // Look for an exe file in this directory
                    if let Ok(entries) = std::fs::read_dir(&path) {
                        for entry in entries.flatten() {
                            if let Some(ext) = entry.path().extension() {
                                if ext == "exe" {
                                    let exe_path = entry.path().to_string_lossy().to_string();
                                    write_debug_log(&format!("Found exe: {}", exe_path));
                                    return Some(exe_path);
                                }
                            }
                        }
                    }
                }
            }
        }
    }

    write_debug_log("Could not resolve Microsoft AutoGenerated path");
    None
}

/// Convert registry-style paths to actual file paths
/// Handles paths like {GUID}\path\to\exe that come from shell parsing
fn convert_registry_path_to_file_path(registry_path: &str) -> Option<String> {
    // Check if it matches the pattern {GUID}\path
    if !registry_path.starts_with('{') || !registry_path.contains('}') {
        return None;
    }

    // Extract the path part after the GUID
    if let Some(guid_end) = registry_path.find('}') {
        let path_part = &registry_path[guid_end + 1..];

        // Get username from environment
        let username = std::env::var("USERNAME").unwrap_or_else(|_| "Default".to_string());

        // Try common installation directories
        let possible_paths = [
            // Program Files
            format!("C:\\Program Files\\{}", path_part),
            format!("C:\\Program Files (x86)\\{}", path_part),
            // Local App Data
            format!("C:\\Users\\{}\\AppData\\Local\\{}", username, path_part),
            // Roaming App Data
            format!("C:\\Users\\{}\\AppData\\Roaming\\{}", username, path_part),
            // Direct path if it's already a full path
            path_part.to_string(),
        ];

        // Check which path exists
        for path in possible_paths {
            if std::path::Path::new(&path).exists() {
                write_debug_log(&format!("Found existing path: {}", path));
                return Some(path);
            }
        }

        // If no path exists, try to construct a reasonable path
        // For VLC, it's usually in Program Files
        if path_part.contains("VideoLAN\\VLC") {
            let vlc_path = format!("C:\\Program Files\\VideoLAN\\VLC\\vlc.exe");
            if std::path::Path::new(&vlc_path).exists() {
                write_debug_log(&format!("Found VLC at default location: {}", vlc_path));
                return Some(vlc_path);
            }
            let vlc_path_x86 = format!("C:\\Program Files (x86)\\VideoLAN\\VLC\\vlc.exe");
            if std::path::Path::new(&vlc_path_x86).exists() {
                write_debug_log(&format!("Found VLC at x86 location: {}", vlc_path_x86));
                return Some(vlc_path_x86);
            }
        }
    }

    None
}

// Custom message for background scan completion
const WM_APP_SCAN_COMPLETE: u32 = WM_USER + 2;

fn main() -> Result<()> {
    unsafe {
        CoInitializeEx(None, COINIT_APARTMENTTHREADED).ok();

        IS_DARK_MODE = utils::is_dark_mode();
        utils::set_dark_mode_preference(IS_DARK_MODE);

        ui::init_common_controls();

        let _ = db::init_db();

        // First, load from cache for fast startup
        {
            let mut manager = APP_MANAGER.lock().unwrap();
            let cached_apps = db::load_app_cache();
            if !cached_apps.is_empty() {
                write_debug_log(&format!("Loaded {} apps from cache", cached_apps.len()));
                for app in cached_apps {
                    manager.add_app_unchecked(app);
                }
                manager.sort_by_usage();
                manager.filter("");
            }
        }

        let instance = GetModuleHandleW(None)?;
        let class_name = w!("OxistartClass");

        // Store instance for later use in background thread

        let wc = WNDCLASSW {
            hCursor: LoadCursorW(None, IDC_ARROW)?,
            hInstance: instance.into(),
            lpszClassName: class_name,
            lpfnWndProc: Some(wnd_proc),
            hbrBackground: utils::get_background_brush(IS_DARK_MODE),
            ..Default::default()
        };

        RegisterClassW(&wc);

        MY_WINDOW = CreateWindowExW(
            WS_EX_TOOLWINDOW | WS_EX_TOPMOST,
            class_name,
            w!("Oxistart"),
            WS_POPUP,
            0,
            0,
            400,
            600,
            None,
            None,
            instance,
            None,
        );

        ui::setup_window_style(MY_WINDOW, IS_DARK_MODE);
        H_FONT = ui::create_ui_font();
        H_CALC_FONT = ui::create_calc_font();
        let _ = ui::add_tray_icon(MY_WINDOW);

        KEYBOARD_HOOK = hooks::setup_keyboard_hook(instance.into(), Some(keyboard_hook))?;
        MOUSE_HOOK = hooks::setup_mouse_hook(instance.into(), Some(mouse_hook))?;

        // Start background scan
        let window_handle = MY_WINDOW.0;
        thread::spawn(move || {
            // Initialize COM for this thread
            let _ = CoInitializeEx(None, COINIT_APARTMENTTHREADED);

            // Scan apps in background
            let mut temp_manager = AppManager::new();
            scanner::scan_apps(&mut temp_manager);

            // Store scanned apps in a global location
            let scanned_apps: Vec<AppEntry> = temp_manager.apps().to_vec();

            // Save to cache
            let _ = db::save_app_cache(&scanned_apps);
            write_debug_log(&format!("Saved {} apps to cache", scanned_apps.len()));

            // Update the main manager
            {
                let mut manager = APP_MANAGER.lock().unwrap();
                manager.clear();
                for app in scanned_apps {
                    manager.add_app(app);
                }
                manager.sort_by_usage();
                manager.filter("");
            }

            // Notify main window to refresh UI
            let _ = PostMessageW(
                HWND(window_handle),
                WM_APP_SCAN_COMPLETE,
                WPARAM(0),
                LPARAM(0),
            );

            CoUninitialize();
        });

        let mut message = MSG::default();
        while GetMessageW(&mut message, None, 0, 0).into() {
            TranslateMessage(&message);
            DispatchMessageW(&message);
        }

        ui::remove_tray_icon(MY_WINDOW);
        let _ = hooks::remove_hook(KEYBOARD_HOOK);
        let _ = hooks::remove_hook(MOUSE_HOOK);
        CoUninitialize();
    }
    Ok(())
}

unsafe fn update_filter(search: &str) {
    // Check if it's a mathematical expression
    if calculator::is_math_expression(search) {
        if let Some(result) = calculator::evaluate(search) {
            // Show calculation result
            let result_text = format!("= {}", result);
            let result_wide = utils::to_wide_string(&result_text);
            let _ = SetWindowTextW(H_CALC_LABEL, PCWSTR(result_wide.as_ptr()));
            ShowWindow(H_CALC_LABEL, SW_SHOW);
        } else {
            ShowWindow(H_CALC_LABEL, SW_HIDE);
        }
    } else {
        ShowWindow(H_CALC_LABEL, SW_HIDE);
    }

    let mut manager = APP_MANAGER.lock().unwrap();
    manager.filter(search);
    ui::update_listview(H_LIST, &manager);
}

unsafe extern "system" fn wnd_proc(
    hwnd: HWND,
    msg: u32,
    wparam: WPARAM,
    lparam: LPARAM,
) -> LRESULT {
    match msg {
        WM_CREATE => {
            // Create search input with larger height
            H_EDIT = CreateWindowExW(
                WS_EX_CLIENTEDGE,
                w!("EDIT"),
                None,
                WINDOW_STYLE((WS_CHILD | WS_VISIBLE | WS_BORDER).0 | ES_AUTOHSCROLL as u32),
                PADDING,
                PADDING,
                400 - PADDING * 2,
                SEARCH_HEIGHT,
                hwnd,
                HMENU(ID_EDIT as isize),
                None,
                None,
            );
            SendMessageW(H_EDIT, WM_SETFONT, WPARAM(H_FONT.0 as usize), LPARAM(1));

            // Set placeholder text
            let placeholder = w!("Search apps and settings...");
            SendMessageW(
                H_EDIT,
                EM_SETCUEBANNER,
                WPARAM(1),
                LPARAM(placeholder.as_ptr() as isize),
            );

            // Create calculator result label (below the input, left-aligned)
            H_CALC_LABEL = CreateWindowExW(
                WINDOW_EX_STYLE(0),
                w!("STATIC"),
                None,
                WINDOW_STYLE(WS_CHILD.0 | 0x00000000), // WS_CHILD | SS_LEFT
                PADDING,
                PADDING + SEARCH_HEIGHT + 5,
                400 - PADDING * 2,
                CALC_LABEL_HEIGHT,
                hwnd,
                HMENU(ID_CALC_RESULT as isize),
                None,
                None,
            );
            SendMessageW(
                H_CALC_LABEL,
                WM_SETFONT,
                WPARAM(H_CALC_FONT.0 as usize),
                LPARAM(1),
            );
            ShowWindow(H_CALC_LABEL, SW_HIDE);

            // Create list view with better styling
            H_LIST = CreateWindowExW(
                WS_EX_CLIENTEDGE,
                w!("SysListView32"),
                None,
                WINDOW_STYLE(
                    (WS_CHILD | WS_VISIBLE).0
                        | LVS_REPORT as u32
                        | LVS_NOCOLUMNHEADER as u32
                        | LVS_SINGLESEL as u32
                        | LVS_SHOWSELALWAYS as u32
                        | LVS_SHAREIMAGELISTS as u32,
                ),
                PADDING,
                LIST_TOP,
                400 - PADDING * 2,
                600 - LIST_TOP - PADDING,
                hwnd,
                HMENU(ID_LIST as isize),
                None,
                None,
            );

            let _ = ui::setup_listview(H_LIST, IS_DARK_MODE);
            SendMessageW(H_LIST, WM_SETFONT, WPARAM(H_FONT.0 as usize), LPARAM(1));

            // Use large image list for better visibility
            let sys_img_list = ui::get_system_image_list();
            if sys_img_list != 0 {
                SendMessageW(
                    H_LIST,
                    LVM_SETIMAGELIST,
                    WPARAM(LVSIL_SMALL as usize),
                    LPARAM(sys_img_list),
                );
            }

            // Set item spacing for larger row height
            SendMessageW(
                H_LIST,
                LVM_SETICONSPACING,
                WPARAM(0),
                LPARAM(((ROW_HEIGHT as isize) << 16) | 32), // width=32, height=ROW_HEIGHT
            );

            // Set column width to fill list view (accounting for vertical scrollbar ~17px)
            let mut col = LVCOLUMNW {
                mask: LVCF_WIDTH,
                cx: 400 - PADDING * 2 - 4 - 17, // -4 for borders, -17 for scrollbar
                ..Default::default()
            };
            SendMessageW(
                H_LIST,
                LVM_INSERTCOLUMNW,
                WPARAM(0),
                LPARAM(&mut col as *mut _ as isize),
            );
            update_filter("");
            LRESULT(0)
        }
        WM_SIZE => {
            let width = (lparam.0 & 0xFFFF) as i32;
            let height = ((lparam.0 >> 16) & 0xFFFF) as i32;
            let _ = MoveWindow(
                H_EDIT,
                PADDING,
                PADDING,
                width - PADDING * 2,
                SEARCH_HEIGHT,
                true,
            );
            let _ = MoveWindow(
                H_CALC_LABEL,
                PADDING,
                PADDING + SEARCH_HEIGHT + 5,
                width - PADDING * 2,
                CALC_LABEL_HEIGHT,
                true,
            );
            let _ = MoveWindow(
                H_LIST,
                PADDING,
                LIST_TOP,
                width - PADDING * 2,
                height - LIST_TOP - PADDING,
                true,
            );
            // Set column width to fill list view (accounting for vertical scrollbar ~17px)
            let mut col = LVCOLUMNW {
                mask: LVCF_WIDTH,
                cx: width - PADDING * 2 - 4 - 17, // -4 for borders, -17 for scrollbar
                ..Default::default()
            };
            SendMessageW(
                H_LIST,
                LVM_SETCOLUMNW,
                WPARAM(0),
                LPARAM(&mut col as *mut _ as isize),
            );
            LRESULT(0)
        }
        WM_COMMAND => {
            let id = wparam.0 & 0xFFFF;
            let code = (wparam.0 >> 16) & 0xFFFF;
            if id == ID_EDIT as usize && code == EN_CHANGE as usize {
                let len = GetWindowTextLengthW(H_EDIT);
                let mut buffer = vec![0u16; (len + 1) as usize];
                GetWindowTextW(H_EDIT, &mut buffer);
                let text = String::from_utf16_lossy(&buffer[..len as usize]);
                update_filter(&text);
            }
            if id == ID_TRAY_EXIT {
                PostQuitMessage(0);
            }
            LRESULT(0)
        }
        WM_NOTIFY => {
            let nmhdr = &*(lparam.0 as *const NMHDR);
            if nmhdr.idFrom == ID_LIST as usize {
                if nmhdr.code == NM_DBLCLK {
                    launch_selected_app();
                }
                if nmhdr.code == LVN_KEYDOWN {
                    let nmkd = &*(lparam.0 as *const NMLVKEYDOWN);
                    if nmkd.wVKey == VK_RETURN.0 {
                        launch_selected_app();
                    }
                }
            }
            LRESULT(0)
        }
        WM_CTLCOLOREDIT => {
            if IS_DARK_MODE {
                let hdc = HDC(wparam.0 as isize);
                SetTextColor(hdc, COLORREF(0x00FFFFFF));
                SetBkColor(hdc, COLORREF(0x00303030));
                return LRESULT(CreateSolidBrush(COLORREF(0x00303030)).0 as isize);
            }
            DefWindowProcW(hwnd, msg, wparam, lparam)
        }
        WM_CTLCOLORSTATIC => {
            // Handle static control (calculator label) colors
            if IS_DARK_MODE {
                let hdc = HDC(wparam.0 as isize);
                SetTextColor(hdc, COLORREF(0x00FFFFFF)); // White text for dark mode
                SetBkColor(hdc, COLORREF(0x00202020)); // Dark background
                return LRESULT(CreateSolidBrush(COLORREF(0x00202020)).0 as isize);
            } else {
                let hdc = HDC(wparam.0 as isize);
                SetTextColor(hdc, COLORREF(0x00000000)); // Black text for light mode
                SetBkColor(hdc, COLORREF(0x00F0F0F0)); // Light background
                return LRESULT(CreateSolidBrush(COLORREF(0x00F0F0F0)).0 as isize);
            }
        }
        WM_APP_SCAN_COMPLETE => {
            // Background scan completed, refresh the listview
            write_debug_log("Background scan completed, refreshing UI");
            update_filter("");
            LRESULT(0)
        }
        WM_APP_TRAY => {
            if lparam.0 as u32 == WM_RBUTTONUP {
                let mut pt = POINT::default();
                let _ = GetCursorPos(&mut pt);
                SetForegroundWindow(hwnd);
                let hmenu = CreatePopupMenu().unwrap_or(HMENU(0));
                let _ = AppendMenuW(hmenu, MF_STRING, ID_TRAY_EXIT, w!("Exit Oxistart"));
                TrackPopupMenu(
                    hmenu,
                    TPM_BOTTOMALIGN | TPM_LEFTALIGN,
                    pt.x,
                    pt.y,
                    0,
                    hwnd,
                    None,
                );
                let _ = DestroyMenu(hmenu);
            }
            LRESULT(0)
        }
        WM_ACTIVATE => {
            if wparam.0 == WA_INACTIVE as usize {
                ShowWindow(hwnd, SW_HIDE);
                let _ = SetWindowTextW(H_EDIT, w!(""));
                update_filter("");
            } else {
                SetFocus(H_EDIT);
                SendMessageW(H_EDIT, EM_SETSEL, WPARAM(0), LPARAM(-1));
            }
            LRESULT(0)
        }
        WM_TIMER => {
            if wparam.0 == WIN_KEY_TIMER_ID {
                // Check if Win key has been held for more than 1 second
                if let Some(press_time) = WIN_KEY_PRESS_TIME {
                    let hold_duration = press_time.elapsed().as_millis();
                    if hold_duration >= WIN_KEY_HOLD_THRESHOLD_MS && !WIN_KEY_NATIVE_TRIGGERED {
                        // Trigger native Start menu immediately
                        WIN_KEY_NATIVE_TRIGGERED = true;
                        KillTimer(MY_WINDOW, WIN_KEY_TIMER_ID);
                        open_native_start_menu();
                    }
                } else {
                    // No key being held, kill timer
                    KillTimer(MY_WINDOW, WIN_KEY_TIMER_ID);
                }
            }
            LRESULT(0)
        }
        WM_DESTROY => {
            PostQuitMessage(0);
            LRESULT(0)
        }
        _ => DefWindowProcW(hwnd, msg, wparam, lparam),
    }
}

unsafe fn launch_selected_app_with_modifier(as_admin: bool, open_location: bool) {
    let sel = SendMessageW(
        H_LIST,
        LVM_GETNEXTITEM,
        WPARAM(usize::MAX),
        LPARAM(LVNI_SELECTED as isize),
    );
    if sel.0 == -1 {
        return;
    }

    let mut item = LVITEMW {
        mask: LVIF_PARAM,
        iItem: sel.0 as i32,
        iSubItem: 0,
        ..Default::default()
    };
    SendMessageW(
        H_LIST,
        LVM_GETITEMW,
        WPARAM(0),
        LPARAM(&mut item as *mut _ as isize),
    );
    let app_idx = item.lParam.0 as usize;

    // Obtener la información necesaria Y liberar el lock ANTES de ejecutar la app
    let (parse_name, parse_name_wide, arguments, arguments_wide, entry_type) = {
        let manager = APP_MANAGER.lock().unwrap();
        if let Some(app) = manager.apps().get(app_idx) {
            let parse_name = app.parse_name.clone();
            let parse_name_wide = utils::to_wide_string(&parse_name);
            let arguments = app.arguments.clone();
            let arguments_wide = arguments.as_ref().map(|a| utils::to_wide_string(a));
            let entry_type = app.entry_type.clone();
            (
                parse_name,
                parse_name_wide,
                arguments,
                arguments_wide,
                entry_type,
            )
        } else {
            return;
        }
    }; // El lock se libera aquí

    // Handle different entry types
    match entry_type {
        AppEntryType::Settings => {
            // Settings items: always open normally, ignore modifiers
            // Open the ms-settings URI
            write_debug_log(&format!("Launching settings: {}", parse_name));
            let result = ShellExecuteW(
                None,
                w!("open"),
                PCWSTR(parse_name_wide.as_ptr()),
                None,
                None,
                SW_SHOW,
            );
            if result.0 <= 32 {
                write_debug_log(&format!(
                    "Failed to launch settings: {} (error code: {})",
                    parse_name, result.0
                ));
            }
        }
        AppEntryType::Application => {
            // Handle different actions for applications
            if open_location {
                // Open file location
                let verb = w!("open");
                let params = format!("/select,\"{}\"", parse_name);
                let params_wide = utils::to_wide_string(&params);
                write_debug_log(&format!("Opening location for: {}", parse_name));
                let result = ShellExecuteW(
                    None,
                    verb,
                    w!("explorer.exe"),
                    PCWSTR(params_wide.as_ptr()),
                    None,
                    SW_SHOW,
                );
                if result.0 <= 32 {
                    write_debug_log(&format!(
                        "Failed to open location: {} (error code: {})",
                        parse_name, result.0
                    ));
                }
            } else if as_admin {
                // Run as administrator
                let verb = w!("runas");
                write_debug_log(&format!("Launching as admin: {}", parse_name));
                let result = ShellExecuteW(
                    None,
                    verb,
                    PCWSTR(parse_name_wide.as_ptr()),
                    None,
                    None,
                    SW_SHOW,
                );
                if result.0 <= 32 {
                    write_debug_log(&format!(
                        "Failed to launch as admin: {} (error code: {})",
                        parse_name, result.0
                    ));
                }
            } else {
                // Normal execution
                write_debug_log(&format!(
                    "Launching normally: {} (args: {:?})",
                    parse_name, arguments
                ));

                // Handle special parse names
                let (final_parse_name, use_explorer) = if parse_name
                    .starts_with("Microsoft.AutoGenerated.")
                    && parse_name.contains('{')
                    && parse_name.contains('}')
                {
                    // This is a Microsoft AutoGenerated parse name
                    // These are typically for Store apps or special Windows apps
                    // Try to find the real application
                    write_debug_log(&format!(
                        "Detected Microsoft AutoGenerated parse name: {}",
                        parse_name
                    ));
                    if let Some(real_path) = resolve_microsoft_auto_generated_path(&parse_name) {
                        write_debug_log(&format!("Resolved AutoGenerated path to: {}", real_path));
                        (real_path, false)
                    } else {
                        write_debug_log(&format!(
                            "Could not resolve AutoGenerated path: {}",
                            parse_name
                        ));
                        (parse_name.clone(), false)
                    }
                } else if parse_name.starts_with('{')
                    && parse_name.contains('}')
                    && parse_name.contains('\\')
                {
                    // This looks like a registry-style path like {GUID}\path\to\exe
                    // Try to convert it to a direct file path
                    if let Some(exe_path) = convert_registry_path_to_file_path(&parse_name) {
                        write_debug_log(&format!("Converted registry path to: {}", exe_path));
                        (exe_path, false)
                    } else {
                        write_debug_log(&format!(
                            "Could not convert registry path: {}",
                            parse_name
                        ));
                        (parse_name.clone(), false)
                    }
                } else {
                    (parse_name.clone(), false)
                };

                let final_parse_name_wide = utils::to_wide_string(&final_parse_name);

                // Pass arguments if available
                let result = if let Some(ref args_wide) = arguments_wide {
                    ShellExecuteW(
                        None,
                        w!("open"),
                        PCWSTR(final_parse_name_wide.as_ptr()),
                        PCWSTR(args_wide.as_ptr()),
                        None,
                        SW_SHOW,
                    )
                } else {
                    ShellExecuteW(
                        None,
                        w!("open"),
                        PCWSTR(final_parse_name_wide.as_ptr()),
                        None,
                        None,
                        SW_SHOW,
                    )
                };

                if result.0 <= 32 {
                    write_debug_log(&format!(
                        "Failed to launch: {} (error code: {})",
                        final_parse_name, result.0
                    ));

                    // Show user-visible error message
                    show_launch_error(&parse_name, result.0 as u32);

                    // Special handling for Microsoft AutoGenerated paths
                    if parse_name.starts_with("Microsoft.AutoGenerated.") {
                        write_debug_log(
                            "Trying alternative methods for Microsoft AutoGenerated path",
                        );

                        // Try with "open" verb explicitly
                        let result2 = ShellExecuteW(
                            None,
                            w!("open"),
                            PCWSTR(parse_name_wide.as_ptr()),
                            None,
                            None,
                            SW_SHOW,
                        );

                        if result2.0 <= 32 {
                            write_debug_log(&format!(
                                "Open verb also failed (error code: {})",
                                result2.0
                            ));

                            // Try with runas (administrator) - some UWP apps need this
                            let result3 = ShellExecuteW(
                                None,
                                w!("runas"),
                                PCWSTR(parse_name_wide.as_ptr()),
                                None,
                                None,
                                SW_SHOW,
                            );

                            if result3.0 <= 32 {
                                write_debug_log(&format!("Runas also failed (error code: {}). This Microsoft AutoGenerated app cannot be launched.", result3.0));
                                write_debug_log("This is likely a system component or Store app that requires special Windows handling.");
                                write_debug_log("Try accessing it through the Start Menu or Settings app instead.");
                            } else {
                                write_debug_log("Runas succeeded for Microsoft AutoGenerated app");
                            }
                        } else {
                            write_debug_log("Open verb succeeded for Microsoft AutoGenerated app");
                        }
                    } else if !use_explorer && final_parse_name != parse_name {
                        // If ShellExecuteW failed, try with explorer.exe for some special cases
                        write_debug_log(&format!("Trying with explorer.exe: {}", final_parse_name));
                        let result2 = ShellExecuteW(
                            None,
                            w!("open"),
                            w!("explorer.exe"),
                            PCWSTR(final_parse_name_wide.as_ptr()),
                            None,
                            SW_SHOW,
                        );
                        if result2.0 <= 32 {
                            write_debug_log(&format!(
                                "Explorer.exe also failed: {} (error code: {})",
                                final_parse_name, result2.0
                            ));
                        } else {
                            write_debug_log(&format!(
                                "Explorer.exe succeeded: {}",
                                final_parse_name
                            ));
                        }
                    }
                } else {
                    write_debug_log(&format!("Successfully launched: {}", final_parse_name));
                }
            }

            // Update usage only for applications, not for settings
            {
                let mut manager = APP_MANAGER.lock().unwrap();
                let _ = db::increment_usage(&parse_name);
                manager.increment_usage(app_idx);
                manager.sort_by_usage();
                manager.filter("");
            }
        }
    }

    // Ocultar ventana
    ShowWindow(MY_WINDOW, SW_HIDE);
    let _ = SetWindowTextW(H_EDIT, w!(""));

    // Actualizar UI sin lock
    update_filter("");
}

unsafe fn launch_selected_app() {
    launch_selected_app_with_modifier(false, false);
}

unsafe fn launch_selected_app_as_admin() {
    launch_selected_app_with_modifier(true, false);
}

unsafe fn launch_selected_app_location() {
    launch_selected_app_with_modifier(false, true);
}

/// Open the native Windows Start menu by clicking the Start button
unsafe fn open_native_start_menu() {
    // Find the Start button and click it
    if let Some(start_rect) = hooks::get_start_button_rect() {
        let center_x = (start_rect.left + start_rect.right) / 2;
        let center_y = (start_rect.top + start_rect.bottom) / 2;

        // Simulate a mouse click on the Start button
        let mut inputs: [INPUT; 2] = std::mem::zeroed();

        // Move mouse to the start button (absolute coordinates)
        let screen_width = GetSystemMetrics(SM_CXSCREEN);
        let screen_height = GetSystemMetrics(SM_CYSCREEN);

        // Convert to absolute coordinates (0-65535 range)
        let abs_x = (center_x * 65535 / screen_width) as u32;
        let abs_y = (center_y * 65535 / screen_height) as u32;

        // Mouse down
        inputs[0].r#type = INPUT_MOUSE;
        inputs[0].Anonymous.mi.dx = abs_x as i32;
        inputs[0].Anonymous.mi.dy = abs_y as i32;
        inputs[0].Anonymous.mi.dwFlags =
            MOUSEEVENTF_ABSOLUTE | MOUSEEVENTF_MOVE | MOUSEEVENTF_LEFTDOWN;

        // Mouse up
        inputs[1].r#type = INPUT_MOUSE;
        inputs[1].Anonymous.mi.dx = abs_x as i32;
        inputs[1].Anonymous.mi.dy = abs_y as i32;
        inputs[1].Anonymous.mi.dwFlags =
            MOUSEEVENTF_ABSOLUTE | MOUSEEVENTF_MOVE | MOUSEEVENTF_LEFTUP;

        SendInput(&inputs, std::mem::size_of::<INPUT>() as i32);
    }
}

unsafe extern "system" fn keyboard_hook(code: i32, wparam: WPARAM, lparam: LPARAM) -> LRESULT {
    if code >= 0 {
        let kbd = &*(lparam.0 as *const KBDLLHOOKSTRUCT);

        // Check if this is an injected input (from SendInput) - let it through
        let is_injected = (kbd.flags.0 & LLKHF_INJECTED) != 0;

        if wparam.0 == WM_KEYDOWN as usize || wparam.0 == WM_SYSKEYDOWN as usize {
            if kbd.vkCode == VK_LWIN.0 as u32 || kbd.vkCode == VK_RWIN.0 as u32 {
                // Let injected keys through to allow SendInput to work
                if is_injected {
                    return CallNextHookEx(KEYBOARD_HOOK, code, wparam, lparam);
                }

                // Record when Win key was pressed (only on initial press, not repeat)
                if WIN_KEY_PRESS_TIME.is_none() {
                    WIN_KEY_PRESS_TIME = Some(std::time::Instant::now());
                    WIN_KEY_NATIVE_TRIGGERED = false;
                    // Start a timer to check for long press
                    SetTimer(MY_WINDOW, WIN_KEY_TIMER_ID, WIN_KEY_TIMER_INTERVAL, None);
                }
                // Block the key down event to prevent native Start menu
                return LRESULT(1);
            }
            if GetForegroundWindow() == MY_WINDOW {
                // Keep focus on the edit control always
                if GetFocus() != H_EDIT {
                    SetFocus(H_EDIT);
                }

                if kbd.vkCode == VK_DOWN.0 as u32 {
                    // Navigate down in the list without changing focus
                    let sel = SendMessageW(
                        H_LIST,
                        LVM_GETNEXTITEM,
                        WPARAM(usize::MAX),
                        LPARAM(LVNI_SELECTED as isize),
                    );
                    let count = SendMessageW(H_LIST, LVM_GETITEMCOUNT, WPARAM(0), LPARAM(0));

                    if sel.0 == -1 && count.0 > 0 {
                        // No selection, select first item
                        let mut item = LVITEMW {
                            mask: LVIF_STATE,
                            state: LIST_VIEW_ITEM_STATE_FLAGS(LVIS_SELECTED.0 | LVIS_FOCUSED.0),
                            stateMask: LIST_VIEW_ITEM_STATE_FLAGS(LVIS_SELECTED.0 | LVIS_FOCUSED.0),
                            iItem: 0,
                            ..Default::default()
                        };
                        SendMessageW(
                            H_LIST,
                            LVM_SETITEMSTATE,
                            WPARAM(0),
                            LPARAM(&mut item as *mut _ as isize),
                        );
                    } else if sel.0 < count.0 - 1 {
                        // Select next item
                        let mut item = LVITEMW {
                            mask: LVIF_STATE,
                            state: LIST_VIEW_ITEM_STATE_FLAGS(0),
                            stateMask: LIST_VIEW_ITEM_STATE_FLAGS(LVIS_SELECTED.0 | LVIS_FOCUSED.0),
                            iItem: sel.0 as i32,
                            ..Default::default()
                        };
                        SendMessageW(
                            H_LIST,
                            LVM_SETITEMSTATE,
                            WPARAM(sel.0 as usize),
                            LPARAM(&mut item as *mut _ as isize),
                        );

                        item.state = LIST_VIEW_ITEM_STATE_FLAGS(LVIS_SELECTED.0 | LVIS_FOCUSED.0);
                        item.iItem = sel.0 as i32 + 1;
                        SendMessageW(
                            H_LIST,
                            LVM_SETITEMSTATE,
                            WPARAM((sel.0 + 1) as usize),
                            LPARAM(&mut item as *mut _ as isize),
                        );
                        SendMessageW(
                            H_LIST,
                            LVM_ENSUREVISIBLE,
                            WPARAM((sel.0 + 1) as usize),
                            LPARAM(0),
                        );
                    }
                    return LRESULT(1);
                }
                if kbd.vkCode == VK_UP.0 as u32 {
                    // Navigate up in the list without changing focus
                    let sel = SendMessageW(
                        H_LIST,
                        LVM_GETNEXTITEM,
                        WPARAM(usize::MAX),
                        LPARAM(LVNI_SELECTED as isize),
                    );

                    if sel.0 > 0 {
                        // Select previous item
                        let mut item = LVITEMW {
                            mask: LVIF_STATE,
                            state: LIST_VIEW_ITEM_STATE_FLAGS(0),
                            stateMask: LIST_VIEW_ITEM_STATE_FLAGS(LVIS_SELECTED.0 | LVIS_FOCUSED.0),
                            iItem: sel.0 as i32,
                            ..Default::default()
                        };
                        SendMessageW(
                            H_LIST,
                            LVM_SETITEMSTATE,
                            WPARAM(sel.0 as usize),
                            LPARAM(&mut item as *mut _ as isize),
                        );

                        item.state = LIST_VIEW_ITEM_STATE_FLAGS(LVIS_SELECTED.0 | LVIS_FOCUSED.0);
                        item.iItem = sel.0 as i32 - 1;
                        SendMessageW(
                            H_LIST,
                            LVM_SETITEMSTATE,
                            WPARAM((sel.0 - 1) as usize),
                            LPARAM(&mut item as *mut _ as isize),
                        );
                        SendMessageW(
                            H_LIST,
                            LVM_ENSUREVISIBLE,
                            WPARAM((sel.0 - 1) as usize),
                            LPARAM(0),
                        );
                    }
                    return LRESULT(1);
                }
                if kbd.vkCode == VK_RETURN.0 as u32 {
                    let is_alt_pressed = GetKeyState(VK_MENU.0 as i32) < 0;
                    let is_shift_pressed = GetKeyState(VK_SHIFT.0 as i32) < 0;

                    if is_alt_pressed {
                        // Alt+Enter: Run as administrator
                        launch_selected_app_as_admin();
                    } else if is_shift_pressed {
                        // Shift+Enter: Open file location
                        launch_selected_app_location();
                    } else {
                        // Normal Enter: Launch app
                        launch_selected_app();
                    }
                    return LRESULT(1);
                }
                if kbd.vkCode == VK_ESCAPE.0 as u32 {
                    if IsWindowVisible(MY_WINDOW).as_bool() {
                        toggle_menu();
                        return LRESULT(1);
                    }
                }
            }
        }
        if wparam.0 == WM_KEYUP as usize || wparam.0 == WM_SYSKEYUP as usize {
            if kbd.vkCode == VK_LWIN.0 as u32 || kbd.vkCode == VK_RWIN.0 as u32 {
                // Let injected keys through
                if is_injected {
                    return CallNextHookEx(KEYBOARD_HOOK, code, wparam, lparam);
                }

                // Kill the timer
                KillTimer(MY_WINDOW, WIN_KEY_TIMER_ID);

                // Check if native Start menu was already triggered
                if WIN_KEY_NATIVE_TRIGGERED {
                    WIN_KEY_PRESS_TIME = None;
                    WIN_KEY_NATIVE_TRIGGERED = false;
                    return LRESULT(1);
                }

                if let Some(_press_time) = WIN_KEY_PRESS_TIME.take() {
                    // Short press: show/hide our custom menu (native would have been triggered by timer)
                    toggle_menu();
                }
                return LRESULT(1);
            }
        }
    }
    CallNextHookEx(KEYBOARD_HOOK, code, wparam, lparam)
}

unsafe extern "system" fn mouse_hook(code: i32, wparam: WPARAM, lparam: LPARAM) -> LRESULT {
    if code >= 0 {
        let msg = wparam.0 as u32;

        // Handle left button clicks
        if msg == WM_LBUTTONDOWN || msg == WM_LBUTTONUP {
            let mouse = &*(lparam.0 as *const MSLLHOOKSTRUCT);
            let pt = POINT {
                x: mouse.pt.x,
                y: mouse.pt.y,
            };

            // Check if this is an injected input - let it through
            let is_injected = (mouse.flags & LLMHF_INJECTED) != 0;
            if is_injected {
                return CallNextHookEx(MOUSE_HOOK, code, wparam, lparam);
            }

            // Check if clicking on start button
            if hooks::is_start_button_click(pt) {
                // Solo abrir el menú en el down, pero bloquear ambos eventos
                if msg == WM_LBUTTONDOWN {
                    toggle_menu();
                }
                return LRESULT(1);
            }

            // Check if clicking outside our menu while it's visible
            if msg == WM_LBUTTONDOWN && IsWindowVisible(MY_WINDOW).as_bool() {
                let mut window_rect = RECT::default();
                if GetWindowRect(MY_WINDOW, &mut window_rect).is_ok() {
                    // Check if click is outside our window
                    if pt.x < window_rect.left
                        || pt.x > window_rect.right
                        || pt.y < window_rect.top
                        || pt.y > window_rect.bottom
                    {
                        // Close the menu
                        ShowWindow(MY_WINDOW, SW_HIDE);
                        let _ = SetWindowTextW(H_EDIT, w!(""));
                        update_filter("");
                        // Don't block the click - let it pass through to whatever was clicked
                    }
                }
            }
        }
    }
    CallNextHookEx(MOUSE_HOOK, code, wparam, lparam)
}

unsafe fn toggle_menu() {
    if IsWindowVisible(MY_WINDOW).as_bool() {
        ShowWindow(MY_WINDOW, SW_HIDE);
        let _ = SetWindowTextW(H_EDIT, w!(""));
        update_filter("");
    } else {
        if let Some(rect) = ui::get_target_rect() {
            // First position the window without showing it
            let _ = SetWindowPos(
                MY_WINDOW,
                HWND_TOPMOST,
                rect.left,
                rect.top,
                rect.right - rect.left,
                rect.bottom - rect.top,
                SWP_NOACTIVATE, // Don't activate yet
            );

            // Show the window
            ShowWindow(MY_WINDOW, SW_SHOW);

            // Force the window to the foreground - this is key for WM_ACTIVATE to work properly
            let foreground_hwnd = GetForegroundWindow();
            let foreground_thread = GetWindowThreadProcessId(foreground_hwnd, None);
            let my_thread = GetCurrentThreadId();

            // Attach to the foreground window's thread to allow stealing focus
            AttachThreadInput(my_thread, foreground_thread, true);

            // BringWindowToTop ensures proper Z-order
            let _ = BringWindowToTop(MY_WINDOW);

            // SetForegroundWindow activates the window (triggers WM_ACTIVATE)
            SetForegroundWindow(MY_WINDOW);

            // Set focus to the edit control
            SetFocus(H_EDIT);

            // Detach from the foreground thread
            AttachThreadInput(my_thread, foreground_thread, false);

            // Select all text in the edit control
            SendMessageW(H_EDIT, EM_SETSEL, WPARAM(0), LPARAM(-1));
        }
    }
}
